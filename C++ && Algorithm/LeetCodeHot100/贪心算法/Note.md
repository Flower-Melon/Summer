# 贪心算法

贪心算法（Greedy Algorithm）是一种用于解决优化问题的算法设计策略。它的基本思想是通过在每一步选择中都采取当前状态下最优的选择（即局部最优解），希望最终能得到全局最优解。贪心算法通常用于解决一些特定类型的问题，比如最小生成树、最短路径、活动选择等。

贪心算法并不适用于所有问题，只有在某些特定情况下才能保证找到全局最优解。一些常见的适用场景包括：

* 活动选择问题：选择不重叠的活动，使得总活动时间最大。
* 最小生成树：如 Kruskal 算法和 Prim 算法。
* 最短路径问题：如 Dijkstra 算法。
* 背包问题（部分情况下）：如 0/1 背包问题的近似解。

判断一个问题是否适用贪心算法有以下标准：

1. 贪心选择性质：在问题的某个阶段，做出的局部最优选择能够引导你到全局最优解。尝试找出一个局部最优解，并验证这个选择是否能在后续步骤中保持最优性。如果局部最优解在某些情况下不导致全局最优解，那么贪心算法可能不适用。

2. 最优子结构性质：一个问题的最优解可以由其子问题的最优解构成。将问题拆分为子问题，检查这些子问题的最优解是否能组合成原问题的最优解。如果不能，那么贪心算法可能不适用。

**贪心标准的选取好像是比较关键**

## 55.跳跃游戏

给你一个非负整数数组`nums`，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回`true`；否则，返回`false`。

输入：`nums = [2,3,1,1,4]`
输出：`true`
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

* 解题思路

不断更新最远可到达距离（实际上就是局部最优解），如果能完成遍历，则说明可以到达最后一个下标

这里必须想明白一个事情，如果最后一个位置是可以到达的，**那么它前面的所有位置一定都可以到达**，因此只需要不断向前遍历，不断维护拓展最远可到底距离，就能知道是否能到达最后一个下标

```cpp
bool canJump(vector<int>& nums) 
{
    int reach = 0; // 可以到达的最远距离
    for(int i = 0; i < nums.size(); i++)
    {
        if(i > reach)
        {
            return false;
        }
        reach = max(reach,i + nums[i]);
    }
    return true;
}
```

此问题确实可以很好地体现贪心算法，先不管最后的目标是否可以到达，只管眼前最远可以到哪里，这样一步步来，终究能走到终点

## 45.跳跃游戏-ii

给定一个长度为 $n$ 的 $0$ 索引整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

`0 <= j <= nums[i]` 且
`i + j < n`
返回到达 $n - 1$ 的最小跳跃次数。测试用例保证可以到达 $n - 1$。


示例：

输入: `nums = [2,3,1,1,4]`
输出: `2`
解释: 跳到最后一个位置的最小跳跃数是 `2`。
     从下标为 `0` 跳到下标为 `1` 的位置，跳 `1` 步，然后跳 `3` 步到达数组的最后一个位置。

* 原始思路

思路大体上是根据当前可走的步长范围，选择`step + nums[i + step]`最大的值作为贪心策略，挑选出最优的`step`，直到到达终点

虽然解决了问题，但是有一些丑陋，而且最坏情况下时间复杂度会到达 $O(n^2)$
```cpp
int jump(vector<int>& nums) 
{
    int ans = 0;
    int i = 0; // 当前下标
    if(nums.size() == 1)
    {
        return 0;
    }
    while(i + nums[i] < nums.size() - 1)
    {
        int step = 1; // 这一次计划跳几步
        for(int j = 1; j <= nums[i]; j++)
        {
            if(j + nums[i + j] > step + nums[i + step])
            {
                step = j;
            }
        }
        i = i + step;
        ans++;
    }
    return ans + 1;
}
```

* 优雅的题解

与上述方法的不同是，实际上只需要维护一个最远可到达距离表就行了，不需要每次选择步长的时候都做一遍比较，不过这鬼思路也很难想到就是了

解释起来比较复杂，代码注释里看吧
```cpp
int jump(vector<int>& nums) 
{
    int ans = 0, mx = 0, last = 0;
    for (int i = 0; i < nums.size() - 1; ++i) 
    {
        mx = max(mx, i + nums[i]); // mx记录了到达last前的最远可达距离
        if (i == last) 
        // 注意这里的意思并非是说i这一步走到了last，而是走到了i~last中mx最大的位置
        {
            last = mx;
            ans++;        
        }
    }
    return ans;
}
```
学习借鉴了此思路在题`763.划分字母区间`中使用